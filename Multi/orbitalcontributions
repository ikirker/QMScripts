#!/usr/bin/env python
# Gets Mulliken orbital % contributions and energy information from both ADF and Gaussian .log files, and can also make SVG graphs of energy levels.
##


import re
import sys
import getopt
import collections
import math
from optparse import OptionParser

# Our (global) MO and SFO tuple specs
MOmaker  = collections.namedtuple("MO", "energy occupancy spin number symmetry components")
SFOmaker = collections.namedtuple("SFO", "percent number otype energy occupancy fragmentNumber fragmentName")

# Part of the ADF read-in process
def processEntry( match, matchType, currentSpin, MO=None ):
  g = match.groups() #Quick shorthand
  #print(matchType)
  #print(match.string)
  #print(g)  

  #If the line includes an MO spec, then we generate a new MO tuple for it
  if matchType=="full": #Then it's a full line, not a sub line
    MO = MOmaker( g[0], g[1], currentSpin, g[2], g[3], list() )
    #MO.energy    = g[0]
    #MO.occupancy = g[1]
    #MO.number    = g[2]
    #MO.symmetry  = g[3]

  #Then we append the SFO specced to the list of components for the MO in hand
  SFO = SFOmaker( g[-7], g[-6], g[-5], g[-4], g[-3], g[-2], g[-1] )
  MO.components.append(SFO)
  #SFO.percent = g[-7]
  #SFO.number  = g[-6]
  #SFO.otype    = g[-5]
  #SFO.energy  = g[-4]
  #SFO.occupancy = g[-3]
  #SFO.fragmentNumber = g[-2]
  #SFO.fragmentName   = g[-1]

  #Then return the MO so that future calls to add more SFOs can use it
  return MO


def componentString(MOcomponents, options):
  dictComponents = dict()
  dictFragmentSums = dict()
  # Note this is a little bad at the moment, since I completely fashioned it by the requirements of the moment
  #  - it doesn't distinguish between different fragments with the same name because I mostly cared about the Actinide
  for SFO in MOcomponents:
    if options.only_show != None:
      if SFO.fragmentName != options.only_show:
        continue
    elif options.dont_show != None:
      if (","+SFO.fragmentName+",") in (","+options.dont_show+","): # Added commas for specificity
        continue
    if (SFO.fragmentName + " " + SFO.otype) not in dictComponents:
      dictComponents[SFO.fragmentName + " " + SFO.otype] = float(SFO.percent)
    else:
      dictComponents[SFO.fragmentName + " " + SFO.otype] += float(SFO.percent)

    if SFO.fragmentName not in dictFragmentSums:
      dictFragmentSums[SFO.fragmentName] = float(SFO.percent)
    else:
      dictFragmentSums[SFO.fragmentName] += float(SFO.percent)

  listFragmentSumStrings = list()
  for fragment in dictFragmentSums:
    listFragmentSumStrings.append("{%s %.0f%%}" % (fragment, dictFragmentSums[fragment]))
    #listFragmentSumStrings.append("{%s %.2f%%}" % (fragment, dictFragmentSums[fragment]))
  listFragmentSumStrings.sort()

  returnString = ""
  #for fragment in dictFragmentSums:
  for fragmentString in listFragmentSumStrings:
    returnString += fragmentString #("{%s %.2f%%}" % (fragment, dictFragmentSums[fragment]))
  returnString += " "  
  if options.skip_components==False:
    for component in dictComponents:
      #returnString += ("(%s, %.2f%%) " % (component, dictComponents[component]))  
      returnString += ("(%s, %.0f%%) " % (component, dictComponents[component]))  
  
  return returnString


def getMOcolour( MO, options ):
  if options.colour_by == "occ" or options.colour_by == None:
    occ = float(MO.occupancy)
    return "green" if occ > 1.8 else "red" if occ < 0.3 else ("#%06x" % (int(0x0000FF + occ*0x008800)))
  # Tricky to account for all cases
  #if options.colour_by == "sym":
  #  return { 'A': 'blue',
  # The above, plus red if the orbital isn't occupied
  #if options.colour_by == "symocc":
  if options.colour_by == "atom":
    True
  if options.colour_by == "metal":
    True
  # The above are waiting for me to separate component string generation and component list generation
  

def makeSVGscale( listOfMOlists, options, componentLabels=True):

  #Iterate over MOs, writing lines according to energy, and saving max and min
  #  Note - SVG origin is at top left
  maxEnergy = -50
  minEnergy = 50
  lines = list()

  series = 0
  for MOlist in listOfMOlists:
    series = series + 1
    lastEnergy = 0
    multiplicity = 0
    for MO in MOlist:
      thisEnergy = float(MO.energy)
      if maxEnergy < thisEnergy:
        maxEnergy = thisEnergy
      if minEnergy > thisEnergy:
        minEnergy = thisEnergy

      #if abs(lastEnergy - thisEnergy) < linesMultipleTolerance:
      #  multiplicity = multiplicity + 1
      #else:
      #  multiplicity = 0
      #lastEnergy = thisEnergy  
      
      #colour = colourList[multiplicity]
      colour = getMOcolour(MO, options) 
      # We can't place the lines on the y axis until we know the overall energy minimum and maximum, so add them to a list for later
      if componentLabels == True:
        label = MO.energy + "  " + componentString(MO.components)
        lines.append([series, MO.energy, colour, label])
      else:
        lines.append([series, MO.energy, colour])

  # Construct internal margins - distances to the graphbox
  #  Measurements are kind of in pixels (scalable pixels, I guess?)

  leftMargin = 150 # We draw the y axis in the left margin, so it should be big
  bottomMargin = 100 # And labels in the bottom margin
  rightMargin = 50
  topMargin = 50

  lineLength = 50
  lineWidth = 0.5
  lineGapBetweenSeries=75
  
  pageWidth = leftMargin + rightMargin + series * lineLength + lineGapBetweenSeries * (series+1)
  pageHeight = 800 # This is our main scaling reference point.

  graphBoxWidth = pageWidth - (leftMargin + rightMargin)
  graphBoxHeight = pageHeight - (topMargin + bottomMargin)

  scaleMax = 0.5 * math.ceil(maxEnergy*2)
  scaleMin = 0.5 * math.floor(minEnergy*2)
  
  # This function converts the MO energies into y coordinates
  scaleFactor = (graphBoxHeight / (scaleMax - scaleMin))
  eScale = lambda y: int (topMargin + (-1 * (float(y) - scaleMax) * scaleFactor ))

  # I think now we can actually make some SVG. \o/

  #lineMultipleTolerance = 0.003 # In whatever units the MO.energy is in
  
  SVGText = "" #Build up the text in this variable. 
  
  #Make scale
  scalePips   = 0.5 # In energy units
  scalePipLength = 3 
  scaleMultiplier = 1
  scaleColour='black'
  scaleStroke = 2 
  scaleTextSize = 18
  scaleFont = "Bitstream Vera"
  axisText = "Energy (eV)"

  # The axis
  SVGText = ( "<line x1='%d' x2='%d' y1='%d' y2='%d' stroke='%s' stroke-width='%d' />\n" %
    (leftMargin, leftMargin, eScale(scaleMin), eScale(scaleMax), scaleColour, scaleStroke) )

  # Count down from scaleMax to scaleMin, putting pips on the axis.
  pip = scaleMax
  while pip >= scaleMin:
    SVGText += ("<line x1='%d' x2='%d' y1='%d' y2='%d' stroke='%s' stroke-width='%d' />\n" %
        (leftMargin - scalePipLength, leftMargin, eScale(pip), eScale(pip), scaleColour, scaleStroke) )
    # This version makes the text half as wide. It looks a bit weird.
    #SVGText += ( "<text x='%d' y='%d' fill='%s' font-family='%s' font-size='%d' transform='scale(0.5,1)'> %-.1f </text>\n" %
    SVGText += ( "<text x='%d' y='%d' fill='%s' font-family='%s' font-size='%d' text-anchor='end'> %-.1f </text>\n" %
        (leftMargin - scalePipLength * 2 , eScale(pip) + scaleTextSize/3, scaleColour, scaleFont, scaleTextSize, pip)  )
    pip -= scalePips

  # Label the axis
  SVGText+= ("<text x='%d' y='%d' fill='%s' font-family='%s' font-size='%d' text-anchor='middle' transform='rotate(-90 %d %d)'> %s </text>\n" %
      (leftMargin/2, pageHeight/2, scaleColour, scaleFont, scaleTextSize, leftMargin/2, pageHeight/2, axisText) )

  # Now draw lines (this doesn't do labels yet)
  for line in lines:
    SVGText += ("<line x1='%d' x2='%d' y1='%d' y2='%d' stroke='%s' stroke-width='%f' /><!--%s-->\n" %
                 ( (leftMargin + line[0] * lineGapBetweenSeries + (line[0] - 1) * lineLength),
                   (leftMargin + line[0] * lineGapBetweenSeries + line[0] * lineLength),
                   eScale(line[1]), eScale(line[1]), line[2], lineWidth, line[1]
                 )
               )

  # Labels
  if options.graph_labels:
    labelCount = 0
    for label in options.graph_labels.split(","):
      labelCount+=1
      SVGText+=("<text x='%d' y='%d' fill='%s' font-family='%s' font-size='%d' text-anchor='middle'> %s </text>\n" %
                 ( leftMargin + labelCount * lineGapBetweenSeries + (labelCount - 0.5) * lineLength,
                   pageHeight - (bottomMargin/2), scaleColour, scaleFont, scaleTextSize, label
                 )
               )

  # Title
  if options.graph_title:
    SVGText+=("<text x='%d' y='%d' fill='%s' font-family='%s' font-size='%d' text-anchor='middle'> %s </text>\n" %
               ( pageWidth/2, 0.8 * topMargin, scaleColour, scaleFont, scaleTextSize+1, options.graph_title )
              )

  #Now we have all the bits, open and write the SVG file
  SVGfile = open(options.svgFilename, "w")
  SVGfile.write("""<?xml version="1.0" standalone="no"?>\n"""+
                """<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n""")

  # Fit the viewbox to the max and min
  SVGfile.write("""<svg version="1.1" baseProfile="full" \n\t xmlns="http://www.w3.org/2000/svg" \n""" + 
                """\t xmlns:xlink="http://www.w3.org/1999/xlink" \n\t xmlns:ev="http://www.w3.org/2001/xml-events" \n""" +
                """\t zoomAndPan="magnify" \n""" + 
                """\t width="%d" height="%d" >\n""" % (pageWidth, pageHeight) )
                #"""\t viewBox = "%d %d %d %d" > \n""" % ( 0, 0, pageWidth, pageHeight ) )
  
  SVGfile.write(SVGText)
                
  # Put a line at the origin if it's in the graph
  if maxEnergy > 0 and minEnergy < 0:
    SVGfile.write('<line x1="5" x2="550" y1="' + str(eScale(0)) + '" y2="' + str(eScale(0)) + '" stroke="red" stroke-width="1" style="stroke-dasharray: 5, 3;" />'+"\n")

  # And we're done. Finish up and close the file.
  SVGfile.write("</svg>")
  SVGfile.close()
  return

def printTSVenergies(MOlist):
  for MO in MOlist:
    sys.stdout.write("%s\t" % MO.energy)
  return

def parseOptions():
  usage = "usage: %prog [options] arg1 ..."
  parser = OptionParser(usage=usage)
  parser.add_option("-s", "--svg", action="store", type="string", dest="svgFilename", default=None, 
                    help="write SVG diagram to FILE", metavar="file")
  parser.add_option("--colourby", action="store", type="string", dest="colour_by", default=None, 
          help="colour orbital points on plot by PARAM", metavar="param")
  parser.add_option("--graphlabels", action="store", type="string", dest="graph_labels", default=None,
          help="labels for each series on an SVG plot", metavar="labels")
  parser.add_option("--graphtitle", action="store", type="string", dest="graph_title", default=None,
          help="title of SVG plot", metavar="title")
  parser.add_option("-a", "--alpha", action="store_true", dest="alpha", default=False,
          help="only consider alpha spin orbitals")
  parser.add_option("-b", "--beta",  action="store_true", dest="beta", default=False,
          help="only consider beta spin orbitals")
  parser.add_option("--nobeta", action="store_true", dest="nobeta", default=False,
          help="remove beta spin orbitals (to get alpha and restricted)")
  parser.add_option("--noalpha", action="store_true", dest="noalpha", default=False,
          help="remove alpha spin orbitals (to get beta and restricted)")
  parser.add_option("-o", "--occ",   action="store_true", dest="occ", default=False,
          help="only consider occupied orbitals")
  parser.add_option("-t", "--tsv",   action="store_true", dest="tsv", default=False,
          help="only print energies as tsv")
  parser.add_option("-m", "--nocomps", action="store_true", dest="skip_components", default=False,
          help="don't print detailed components")
  parser.add_option("-l", action="store", type="float", dest="min_energy", default=None, help="Lower energy bound")
  parser.add_option("-u", action="store", type="float", dest="max_energy", default=None, help="Upper energy bound")
  parser.add_option("--minocc", action="store", type="float", dest="minocc", default=None, help="Minimum occupation")
  parser.add_option("--maxocc", action="store", type="float", dest="maxocc", default=None, help="Maximum occupation")
  parser.add_option("-d", "--remove_degeneracy", action="store_true", dest="remove_degeneracy", default=False,
          help="remove degenerate orbitals")
  parser.add_option("--only-show", action="store", type="string", dest="only_show", default=None,
          help="Only show percentage components of a certain atom", metavar="atom")
  parser.add_option("--dont-show", metavar="atom1,atom2,...", action="store", type="string", dest="dont_show", default=None,
          help="Don't show percentage components of certain atoms")
  #I'd like to add this but first TODO I'd have to convert the energies to actually be numbers below
  #  and it'd involve a fair bit of fiddling
  #parser.add_option("-u", "--units", action="store", type="string", dest="units", default="eV",
  #        help="select units for text output (default=eV, options=Hartree, eV, cm^-1, kJ/mol")
  (options, args) = parser.parse_args()
  
  if len(args) == 0:
    parser.print_help()
    sys.exit(2)
  
  return (options,args)

def readADForbitalContributions(lines):
  reSection = re.compile("[ \t]+List of all MOs, ordered by energy, with the most significant SFO gross populations")
  reSpin    = re.compile("[ \t]+\*\*\* SPIN (\d) \*\*\*")
  reSubsection = re.compile("[ \t]+-------------------------------------------------------------------------------------")

  markSection = False
  markSubsection = False  
  spin = 0
  
  # Sample output from ADF 
  #          E(eV)  Occ       MO           %     SFO (first member)   E(eV)  Occ   Fragment
  # e.g.
  #     -22.427  1.00    37 AA        35.01%     5 P:y           -22.819  2.00     1 Am
  #                                   14.31%     5 P:x           -22.819  2.00     1 Am
                     
  reTopEntry = re.compile("""[ \t]+
                ([-]{0,1}\d+\.\d+)[ \t]+
                (\d\.\d+)[ \t]+
                (\d+)[ ]+(\w+|\w+:\d+)[ \t]+
                (\d+\.\d+)%[ \t]+
                (\d+)[ \t]+
                (\w:\S+|\w)[ \t]+
                ([-]{0,1}\d+\.\d+)[ \t]+
                (\d\.\d+)[ \t]+
                (\d+)[ \t]+
                (\w+)""", re.X)
  reSubEntry = re.compile("""[ \t]+
                ([-]{0,1}\d+\.\d+)%[ \t]+
                (\d+)[ \t]+
                (\w:\S+|\w)[ \t]+
                ([-]{0,1}\d+\.\d+)[ \t]+
                (\d\.\d+)[ \t]+
                (\d+)[ \t]+
                (\w+)""", re.X)

  reNextSection = re.compile("[ \t]+===============================================================================")
  
  #Done defining Regexps, now read in orbitals
  MOlist = list()

  for line in lines:
    
    if markSection == False:
      if reSection.match(line)!=None:
        markSection = True
        continue
    else:
      if markSubsection == False:
        if reSubsection.match(line)!=None:
          markSubsection = True
          continue
      else:
        maLine = reTopEntry.match(line)
        if maLine != None:
          #Pull out entry bits
          mostRecentMO = processEntry( maLine, "full", spin )
          MOlist.append(mostRecentMO)
          continue
        else:
          maLine = reSubEntry.match(line)
          if maLine != None:
            #Pull out subentry bits
            processEntry( maLine, "sub", spin, mostRecentMO )
            continue
        if reNextSection.match(line) != None:
          break
      maLine = reSpin.match(line)
      if maLine != None:
        spin = maLine.group(1)
  #Done for
  return MOlist

def readG09orbitalContributions(lines):
  #The G09 output is a bit simpler and contains less information, unfortunately,
  # so we have to omit some fields
  reStartSection = re.compile(" Atomic contributions to (Alpha|Beta ) molecular orbitals:")
  reEntry        = re.compile("(Alpha|Beta ) (occ|vir) (\d+) OE=([-]?\d+\.\d+) is (.*?)(?=(Alpha|Beta|$))")
  reBlankLine    = re.compile("[\t ]*$")

  inSection = False
  MOlist = list()

  orbLines = ""

  for line in lines:
    #Because Gaussian only has something like a 200 character buffer for the
    #  output for this section, we need to glue the lines together and then
    #  split them apart again.
    
    if inSection == False:
      maStartSection = reStartSection.match(line)
      if maStartSection == None:
        continue
      else:
        inSection = True
    else:
      if reBlankLine.match(line) != None:
        inSection = False
        continue
      orbLines = orbLines + line.lstrip(' ').rstrip("\n")  
    

  for maOrb in reEntry.finditer(orbLines):  
    if maOrb.group(1) == "Alpha":
      spinLabel = "1"
    elif maOrb.group(1) == "Beta ":
      spinLabel = "2"
    else:
      spinLabel = "0" # TODO At some stage I really should test this with a closed-shell system
    
    if maOrb.group(2) == "occ":
      occLabel = "1.00"
    else:
      occLabel = "0.00" # TODO And also I haven't seen how Gaussian prints partially occupied orbitals here
      
    # Gaussian prints the energies in Hartrees, ADF in eV - other functions expect eV
    currentMO = MOmaker(str(27.2116*float(maOrb.group(4))), occLabel, spinLabel, maOrb.group(3), "?", list() )  
    
    componentText = maOrb.group(5)
    for m in re.finditer("([A-Za-z]+)(\d+)-(\w)=([-]?\d\.\d\d)", componentText):
      #print("%s| |%s| |%s| |%s" % (m.group(1), m.group(2), m.group(3), m.group(4)))
      currentMO.components.append(
          SFOmaker(str(100*float(m.group(4))),
              "_", 
              m.group(3), "_", 
              "_", m.group(2), 
              m.group(1)))
    MOlist.append(currentMO)      
    #SFOmaker = collections.namedtuple("SFO", "percent number otype energy occupancy fragmentNumber fragmentName")
  
  return MOlist

def filterByList(thing, filters):
  for f in filters:
    if f(thing) == False:
      return False
  return True

def filterMOlist(MOlist, options):
  #MOmaker  = collections.namedtuple("MO", "energy occupancy spin number symmetry components")
  filterList = list()
  
  if options.alpha:
    filterList.append( lambda MO: MO.spin=="1" )
  if options.beta:
    filterList.append( lambda MO: MO.spin=="2" )
  if options.noalpha:
    filterList.append( lambda MO: MO.spin!="1" )
  if options.nobeta:
    filterList.append( lambda MO: MO.spin!="2" )
  if options.occ:
    filterList.append( lambda MO: float(MO.occupancy) >= 0.5 )
  if options.minocc:
    filterList.append( lambda MO: float(MO.occupancy) >= options.minocc )
  if options.maxocc:
    filterList.append( lambda MO: float(MO.occupancy) <= options.maxocc )
  if options.min_energy:
    filterList.append( lambda MO: float(MO.energy) >= options.min_energy )
  if options.max_energy:
    filterList.append( lambda MO: float(MO.energy) <= options.max_energy )
 
  filterByListLambda = lambda x: filterByList(x,filterList)
  MOlist = filter(filterByListLambda, MOlist)

  #if options.remove_degeneracy: # This is a two-orbital operation, so it can't be in the list above
  return MOlist


def getFileType(filename):
  extensions = {'out': 'adf', 'log': 'g09'}
  reFilename = re.compile("(.*)\.(%s)$" % ('|'.join(extensions.keys())))
  maFilename = reFilename.match(filename)
  if maFilename==None:
    sys.stderr.write("File '%s' has inappropriate extension.")
    sys.exit(2)
  return extensions[maFilename.group(2)]

def main():

  (options, args) = parseOptions()

  listOfMOlists = list()

  for inputFilename in args:
    print("File: %s" %(inputFilename))  
    inputFileType = getFileType(inputFilename)
    inputFile = open(inputFilename, "r")
    lines = inputFile.readlines()

    if inputFileType == 'adf':
      MOlist = readADForbitalContributions(lines)
    if inputFileType == 'g09':
      MOlist = readG09orbitalContributions(lines)
    
    print("  Read in "+str(len(MOlist))+" MOs.")
    MOlist = filterMOlist(MOlist, options)
    
    if options.remove_degeneracy:
      MOlist2 = list()
      lastEnergy=0
      for MO in MOlist:
        if MO.energy != lastEnergy: # Remember this is actually a string comparison
          MOlist2.append(MO)
        lastEnergy = MO.energy
      MOlist = MOlist2    
    
    print("  Filtered to " + str(len(MOlist)) + " MOs.")

    #Sort the list of MOs by energy
    MOlist.sort(key=lambda MO: float(MO.energy))

    listOfMOlists.append(MOlist)

    inputFile.close() 

  for MOlist in listOfMOlists:
    for MO in MOlist:
      spinLabel = "+" if (int(MO.spin) == 1) else "-" if (int(MO.spin) == 2) else "+-"
      sys.stdout.write("%3s %5s%1s: %7s eV, %s occ: " % (MO.number, MO.symmetry, spinLabel, MO.energy, MO.occupancy))
      sys.stdout.write("%s \n" % (componentString(MO.components,options))) 
    if options.tsv:
      sys.stdout.write("--TSV--\n")
      printTSVenergies(MOlist)
  
  
  if options.svgFilename:  
    makeSVGscale(listOfMOlists, options, False)

if __name__ == "__main__":
  main()  

